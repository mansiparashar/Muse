{"ast":null,"code":"import Debug from 'debug';\nimport React from 'react';\nimport Types from 'prop-types';\nimport SlateTypes from 'slate-prop-types';\nimport ImmutableTypes from 'react-immutable-proptypes';\nimport { Set } from 'immutable';\nimport logger from 'slate-dev-logger';\nimport { Node, Range, Block, Inline, Text, Schema, Stack } from 'slate';\nimport getWindow from 'get-window';\nimport isBackward from 'selection-is-backward';\nimport { IS_IE, IS_EDGE, IS_SAFARI, IS_IOS, IS_FIREFOX, IS_ANDROID, SUPPORTED_EVENTS } from 'slate-dev-environment';\nimport throttle from 'lodash/throttle';\nimport Base64 from 'slate-base64-serializer';\nimport Plain from 'slate-plain-serializer';\nimport Hotkeys from 'slate-hotkeys';\nimport { findDOMNode } from 'react-dom';\nimport Portal from 'react-portal';\n/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onClick', 'onContextMenu', 'onCompositionEnd', 'onCompositionStart', 'onCopy', 'onCut', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onInput', 'onFocus', 'onKeyDown', 'onKeyUp', 'onPaste', 'onSelect'];\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\n\nvar PLUGIN_PROPS = [].concat(toConsumableArray(EVENT_HANDLERS), ['decorateNode', 'onChange', 'renderEditor', 'renderMark', 'renderNode', 'renderPlaceholder', 'renderPortal', 'schema', 'validateNode']);\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nvar PARSER = /^([\\w-]+)(?::(\\d+))?$/;\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n\n  if (!matches) {\n    throw new Error(\"Invalid offset key string \\\"\" + string + \"\\\".\");\n  }\n\n  var _matches = slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\n\nfunction stringify(object) {\n  return object.key + \":\" + object.index;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar OffsetKey = {\n  parse: parse,\n  stringify: stringify\n};\n/**\n * Debugger.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:leaves');\n/**\n * Leaf.\n *\n * @type {Component}\n */\n\nvar Leaf = function (_React$Component) {\n  inherits(Leaf, _React$Component);\n\n  function Leaf() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Leaf);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Leaf.__proto__ || Object.getPrototypeOf(Leaf)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Leaf, [{\n    key: 'shouldComponentUpdate',\n\n    /**\n     * Should component update?\n     *\n     * @param {Object} props\n     * @return {Boolean}\n     */\n    value: function shouldComponentUpdate(props) {\n      // If any of the regular properties have changed, re-render.\n      if (props.index != this.props.index || props.marks != this.props.marks || props.text != this.props.text || props.parent != this.props.parent) {\n        return true;\n      } // Otherwise, don't update.\n\n\n      return false;\n    }\n    /**\n     * Render the leaf.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      this.debug('render', this);\n      var _props = this.props,\n          node = _props.node,\n          index = _props.index;\n      var offsetKey = OffsetKey.stringify({\n        key: node.key,\n        index: index\n      });\n      return React.createElement('span', {\n        'data-offset-key': offsetKey\n      }, this.renderMarks());\n    }\n    /**\n     * Render all of the leaf's mark components.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderMarks',\n    value: function renderMarks() {\n      var _props2 = this.props,\n          marks = _props2.marks,\n          node = _props2.node,\n          offset = _props2.offset,\n          text = _props2.text,\n          editor = _props2.editor;\n      var stack = editor.stack;\n      var leaf = this.renderText();\n      var attributes = {\n        'data-slate-leaf': true\n      };\n      return marks.reduce(function (children, mark) {\n        var props = {\n          editor: editor,\n          mark: mark,\n          marks: marks,\n          node: node,\n          offset: offset,\n          text: text,\n          children: children,\n          attributes: attributes\n        };\n        var element = stack.find('renderMark', props);\n        return element || children;\n      }, leaf);\n    }\n    /**\n     * Render the text content of the leaf, accounting for browsers.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'renderText',\n    value: function renderText() {\n      var _props3 = this.props,\n          block = _props3.block,\n          node = _props3.node,\n          parent = _props3.parent,\n          text = _props3.text,\n          index = _props3.index,\n          leaves = _props3.leaves; // COMPAT: Render text inside void nodes with a zero-width space.\n      // So the node can contain selection but the text is not visible.\n\n      if (parent.isVoid) {\n        return React.createElement('span', {\n          'data-slate-zero-width': 'z'\n        }, '\\u200B');\n      } // COMPAT: If this is the last text node in an empty block, render a zero-\n      // width space that will convert into a line break when copying and pasting\n      // to support expected plain text.\n\n\n      if (text === '' && parent.object === 'block' && parent.text === '' && parent.nodes.size === 1) {\n        return React.createElement('span', {\n          'data-slate-zero-width': 'n'\n        }, '\\u200B');\n      } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n      // void node, so we render a zero-width space so that the selection can be\n      // inserted next to it still.\n\n\n      if (text === '') {\n        return React.createElement('span', {\n          'data-slate-zero-width': 'z'\n        }, '\\u200B');\n      } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n      // so we need to add an extra trailing new lines to prevent that.\n\n\n      var lastText = block.getLastText();\n      var lastChar = text.charAt(text.length - 1);\n      var isLastText = node === lastText;\n      var isLastLeaf = index === leaves.size - 1;\n      if (isLastText && isLastLeaf && lastChar === '\\n') return text + '\\n'; // Otherwise, just return the text.\n\n      return text;\n    }\n  }]);\n  return Leaf;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nLeaf.propTypes = {\n  block: SlateTypes.block.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: SlateTypes.leaves.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    debug.apply(undefined, [message, _this2.props.node.key + '-' + _this2.props.index].concat(args));\n  };\n};\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$1 = Debug('slate:node');\n/**\n * Text.\n *\n * @type {Component}\n */\n\nvar Text$1 = function (_React$Component) {\n  inherits(Text$$1, _React$Component);\n\n  function Text$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Text$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Text$$1.__proto__ || Object.getPrototypeOf(Text$$1)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default prop types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n\n  createClass(Text$$1, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _this2 = this;\n\n      this.debug('render', this);\n      var _props = this.props,\n          decorations = _props.decorations,\n          editor = _props.editor,\n          node = _props.node,\n          style = _props.style;\n      var value = editor.value;\n      var document = value.document;\n      var key = node.key;\n      var decs = decorations.filter(function (d) {\n        var startKey = d.startKey,\n            endKey = d.endKey;\n        if (startKey == key || endKey == key) return true;\n        if (startKey === endKey) return false;\n        var startsBefore = document.areDescendantsSorted(startKey, key);\n        if (!startsBefore) return false;\n        var endsAfter = document.areDescendantsSorted(key, endKey);\n        return endsAfter;\n      }); // PERF: Take advantage of cache by avoiding arguments\n\n      var leaves = decs.size === 0 ? node.getLeaves() : node.getLeaves(decs);\n      var offset = 0;\n      var children = leaves.map(function (leaf, i) {\n        var child = _this2.renderLeaf(leaves, leaf, i, offset);\n\n        offset += leaf.text.length;\n        return child;\n      });\n      return React.createElement('span', {\n        'data-key': key,\n        style: style\n      }, children);\n    }\n    /**\n     * Render a single leaf given a `leaf` and `offset`.\n     *\n     * @param {List<Leaf>} leaves\n     * @param {Leaf} leaf\n     * @param {Number} index\n     * @param {Number} offset\n     * @return {Element} leaf\n     */\n\n  }]);\n  return Text$$1;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nText$1.propTypes = {\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object\n};\nText$1.defaultProps = {\n  style: null\n};\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key;\n    debug$1.apply(undefined, [message, key + ' (text)'].concat(args));\n  };\n\n  this.shouldComponentUpdate = function (nextProps) {\n    var props = _this3.props;\n    var n = nextProps;\n    var p = props; // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n\n    if (n.node != p.node) return true; // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n\n    if (n.parent.object == 'block') {\n      var pLast = p.parent.nodes.last();\n      var nLast = n.parent.nodes.last();\n      if (p.node == pLast && n.node != nLast) return true;\n    } // Re-render if the current decorations have changed.\n\n\n    if (!n.decorations.equals(p.decorations)) return true; // Otherwise, don't update.\n\n    return false;\n  };\n\n  this.renderLeaf = function (leaves, leaf, index, offset) {\n    var _props2 = _this3.props,\n        block = _props2.block,\n        node = _props2.node,\n        parent = _props2.parent,\n        editor = _props2.editor;\n    var text = leaf.text,\n        marks = leaf.marks;\n    return React.createElement(Leaf, {\n      key: node.key + '-' + index,\n      block: block,\n      editor: editor,\n      index: index,\n      marks: marks,\n      node: node,\n      offset: offset,\n      parent: parent,\n      leaves: leaves,\n      text: text\n    });\n  };\n};\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$2 = Debug('slate:void');\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$2.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Void, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var props = this.props;\n      var children = props.children,\n          node = props.node,\n          readOnly = props.readOnly;\n      var Tag = node.object == 'block' ? 'div' : 'span';\n      var style = {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      };\n      var spacer = React.createElement(Tag, {\n        'data-slate-spacer': true,\n        style: style\n      }, this.renderText());\n      var content = React.createElement(Tag, {\n        contentEditable: readOnly ? null : false\n      }, children);\n      this.debug('render', {\n        props: props\n      });\n      return React.createElement(Tag, {\n        'data-slate-void': true,\n        'data-key': node.key,\n        contentEditable: readOnly || node.object == 'block' ? null : false\n      }, readOnly ? null : spacer, content);\n    }\n    /**\n     * Render the void node's text node, which will catch the cursor when it the\n     * void node is navigated to with the arrow keys.\n     *\n     * Having this text node there means the browser continues to manage the\n     * selection natively, so it keeps track of the right offset when moving\n     * across the block.\n     *\n     * @return {Element}\n     */\n\n  }]);\n  return Void;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nVoid.propTypes = {\n  block: SlateTypes.block,\n  children: Types.any.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired\n};\n\nvar _initialiseProps$2 = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n    var id = key + ' (' + type + ')';\n    debug$2.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.renderText = function () {\n    var _props = _this2.props,\n        block = _props.block,\n        decorations = _props.decorations,\n        node = _props.node,\n        readOnly = _props.readOnly,\n        editor = _props.editor;\n    var child = node.getFirstText();\n    return React.createElement(Text$1, {\n      block: node.object == 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n/**\n * Split the decorations in lists of relevant decorations for each child.\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<List<Decoration>>}\n */\n\n\nfunction getChildrenDecorations(node, decorations) {\n  var activeDecorations = Set().asMutable();\n  var childrenDecorations = [];\n  orderChildDecorations(node, decorations).forEach(function (item) {\n    if (item.isRangeStart) {\n      // Item is a decoration start\n      activeDecorations.add(item.decoration);\n    } else if (item.isRangeEnd) {\n      // item is a decoration end\n      activeDecorations.remove(item.decoration);\n    } else {\n      // Item is a child node\n      childrenDecorations.push(activeDecorations.toList());\n    }\n  });\n  return childrenDecorations;\n}\n/**\n * Orders the children of provided node and its decoration endpoints (start, end)\n * so that decorations can be passed only to relevant children (see use in Node.render())\n *\n * @param {Node} node\n * @param {List} decorations\n * @return {Array<Item>}\n *\n * where type Item =\n * {\n *   child: Node,\n *   // Index of the child in its parent\n *   index: number\n * }\n * or {\n *   // True if this represents the start of the given decoration\n *   isRangeStart: boolean,\n *   // True if this represents the end of the given decoration\n *   isRangeEnd: boolean,\n *   decoration: Range\n * }\n */\n\n\nfunction orderChildDecorations(node, decorations) {\n  if (decorations.isEmpty()) {\n    return node.nodes.toArray().map(function (child, index) {\n      return {\n        child: child,\n        index: index\n      };\n    });\n  } // Map each key to its global order\n\n\n  var keyOrders = defineProperty({}, node.key, 0);\n  var globalOrder = 1;\n  node.forEachDescendant(function (child) {\n    keyOrders[child.key] = globalOrder;\n    globalOrder = globalOrder + 1;\n  });\n  var childNodes = node.nodes.toArray();\n  var endPoints = childNodes.map(function (child, index) {\n    return {\n      child: child,\n      index: index,\n      order: keyOrders[child.key]\n    };\n  });\n  decorations.forEach(function (decoration) {\n    // Range start.\n    // A rangeStart should be before the child containing its startKey, in order\n    // to consider it active before going down the child.\n    var startKeyOrder = keyOrders[decoration.startKey];\n    var containingChildOrder = startKeyOrder === undefined ? 0 : getContainingChildOrder(childNodes, keyOrders, startKeyOrder);\n    endPoints.push({\n      isRangeStart: true,\n      order: containingChildOrder - 0.5,\n      decoration: decoration\n    }); // Range end.\n\n    var endKeyOrder = (keyOrders[decoration.endKey] || globalOrder) + 0.5;\n    endPoints.push({\n      isRangeEnd: true,\n      order: endKeyOrder,\n      decoration: decoration\n    });\n  });\n  return endPoints.sort(function (a, b) {\n    return a.order > b.order ? 1 : -1;\n  });\n}\n/*\n * Returns the key order of the child right before the given order.\n */\n\n\nfunction getContainingChildOrder(children, keyOrders, order) {\n  // Find the first child that is after the given key\n  var nextChildIndex = children.findIndex(function (child) {\n    return order < keyOrders[child.key];\n  });\n\n  if (nextChildIndex <= 0) {\n    return 0;\n  }\n\n  var containingChild = children[nextChildIndex - 1];\n  return keyOrders[containingChild.key];\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$3 = Debug('slate:node');\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node$1 = function (_React$Component) {\n  inherits(Node$$1, _React$Component);\n\n  function Node$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Node$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Node$$1.__proto__ || Object.getPrototypeOf(Node$$1)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$3.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n\n  createClass(Node$$1, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _this2 = this;\n\n      this.debug('render', this);\n      var _props = this.props,\n          editor = _props.editor,\n          isSelected = _props.isSelected,\n          isFocused = _props.isFocused,\n          node = _props.node,\n          decorations = _props.decorations,\n          parent = _props.parent,\n          readOnly = _props.readOnly;\n      var value = editor.value;\n      var selection = value.selection;\n      var stack = editor.stack;\n      var indexes = node.getSelectionIndexes(selection, isSelected);\n      var decs = decorations.concat(node.getDecorations(stack));\n      var childrenDecorations = getChildrenDecorations(node, decs);\n      var children = [];\n      node.nodes.forEach(function (child, i) {\n        var isChildSelected = !!indexes && indexes.start <= i && i < indexes.end;\n        children.push(_this2.renderNode(child, isChildSelected, childrenDecorations[i]));\n      }); // Attributes that the developer must mix into the element in their\n      // custom node renderer component.\n\n      var attributes = {\n        'data-key': node.key // If it's a block node with inline children, add the proper `dir` attribute\n        // for text direction.\n\n      };\n\n      if (node.object == 'block' && node.nodes.first().object != 'block') {\n        var direction = node.getTextDirection();\n        if (direction == 'rtl') attributes.dir = 'rtl';\n      }\n\n      var props = {\n        key: node.key,\n        editor: editor,\n        isFocused: isFocused,\n        isSelected: isSelected,\n        node: node,\n        parent: parent,\n        readOnly: readOnly\n      };\n      var placeholder = stack.find('renderPlaceholder', props);\n\n      if (placeholder) {\n        placeholder = React.cloneElement(placeholder, {\n          key: node.key + '-placeholder'\n        });\n        children = [placeholder].concat(toConsumableArray(children));\n      }\n\n      var element = stack.find('renderNode', _extends({}, props, {\n        attributes: attributes,\n        children: children\n      }));\n      return node.isVoid ? React.createElement(Void, this.props, element) : element;\n    }\n    /**\n     * Render a `child` node.\n     *\n     * @param {Node} child\n     * @param {Boolean} isSelected\n     * @param {Array<Decoration>} decorations\n     * @return {Element}\n     */\n\n  }]);\n  return Node$$1;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nNode$1.propTypes = {\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  isFocused: Types.bool.isRequired,\n  isSelected: Types.bool.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired\n};\n\nvar _initialiseProps$3 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key,\n        type = node.type;\n    debug$3.apply(undefined, [message, key + ' (' + type + ')'].concat(args));\n  };\n\n  this.shouldComponentUpdate = function (nextProps) {\n    var props = _this3.props;\n    var stack = props.editor.stack;\n    var shouldUpdate = stack.find('shouldNodeComponentUpdate', props, nextProps);\n    var n = nextProps;\n    var p = props; // If the `Component` has a custom logic to determine whether the component\n    // needs to be updated or not, return true if it returns true. If it returns\n    // false, we need to ignore it, because it shouldn't be allowed it.\n\n    if (shouldUpdate != null) {\n      if (shouldUpdate) {\n        return true;\n      }\n\n      if (shouldUpdate === false) {\n        logger.warn(\"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\");\n      }\n    } // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n\n\n    if (n.readOnly != p.readOnly) return true; // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n\n    if (n.node != p.node) return true; // If the selection value of the node or of some of its children has changed,\n    // re-render in case there is any user-land logic depends on it to render.\n    // if the node is selected update it, even if it was already selected: the\n    // selection value of some of its children could have been changed and they\n    // need to be rendered again.\n\n    if (n.isSelected || p.isSelected) return true;\n    if (n.isFocused || p.isFocused) return true; // If the decorations have changed, update.\n\n    if (!n.decorations.equals(p.decorations)) return true; // Otherwise, don't update.\n\n    return false;\n  };\n\n  this.renderNode = function (child, isSelected, decorations) {\n    var _props2 = _this3.props,\n        block = _props2.block,\n        editor = _props2.editor,\n        node = _props2.node,\n        readOnly = _props2.readOnly,\n        isFocused = _props2.isFocused;\n    var Component = child.object == 'text' ? Text$1 : Node$1;\n    return React.createElement(Component, {\n      block: node.object == 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      isSelected: isSelected,\n      isFocused: isFocused && isSelected,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\n\nfunction findDOMNode$1(key) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\n  if (Node.isNode(key)) {\n    key = key.key;\n  }\n\n  var el = win.document.querySelector('[data-key=\"' + key + '\"]');\n\n  if (!el) {\n    throw new Error('Unable to find a DOM node for \"' + key + '\". This is often because of forgetting to add `props.attributes` to a custom component.');\n  }\n\n  return el;\n}\n/**\n * Find a native DOM selection point from a Slate `key` and `offset`.\n *\n * @param {String} key\n * @param {Number} offset\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMPoint(key, offset) {\n  var win = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : window;\n  var el = findDOMNode$1(key, win);\n  var start = 0;\n  var n = void 0; // COMPAT: In IE, this method's arguments are not optional, so we have to\n  // pass in all four even though the last two are defaults. (2017/10/25)\n\n  var iterator = win.document.createNodeIterator(el, NodeFilter.SHOW_TEXT, function () {\n    return NodeFilter.FILTER_ACCEPT;\n  }, false);\n\n  while (n = iterator.nextNode()) {\n    var length = n.textContent.length;\n    var end = start + length;\n\n    if (offset <= end) {\n      var o = offset - start;\n      return {\n        node: n,\n        offset: o >= 0 ? o : 0\n      };\n    }\n\n    start = end;\n  }\n\n  return null;\n}\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMRange(range) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  var anchorKey = range.anchorKey,\n      anchorOffset = range.anchorOffset,\n      focusKey = range.focusKey,\n      focusOffset = range.focusOffset,\n      isBackward$$1 = range.isBackward,\n      isCollapsed = range.isCollapsed;\n  var anchor = findDOMPoint(anchorKey, anchorOffset, win);\n  var focus = isCollapsed ? anchor : findDOMPoint(focusKey, focusOffset, win);\n  if (!anchor || !focus) return null;\n  var r = win.document.createRange();\n  var start = isBackward$$1 ? focus : anchor;\n  var end = isBackward$$1 ? anchor : focus;\n  r.setStart(start.node, start.offset);\n  r.setEnd(end.node, end.offset);\n  return r;\n}\n/**\n * Constants.\n *\n * @type {String}\n */\n\n\nvar ZERO_WIDTH_ATTRIBUTE = 'data-slate-zero-width';\nvar ZERO_WIDTH_SELECTOR = '[' + ZERO_WIDTH_ATTRIBUTE + ']';\nvar OFFSET_KEY_ATTRIBUTE = 'data-offset-key';\nvar RANGE_SELECTOR = '[' + OFFSET_KEY_ATTRIBUTE + ']';\nvar TEXT_SELECTOR = '[data-key]';\nvar VOID_SELECTOR = '[data-slate-void]';\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Value} value\n * @return {Object}\n */\n\nfunction findPoint(nativeNode, nativeOffset, value) {\n  var _normalizeNodeAndOffs = normalizeNodeAndOffset(nativeNode, nativeOffset),\n      nearestNode = _normalizeNodeAndOffs.node,\n      nearestOffset = _normalizeNodeAndOffs.offset;\n\n  var window = getWindow(nativeNode);\n  var parentNode = nearestNode.parentNode;\n  var rangeNode = parentNode.closest(RANGE_SELECTOR);\n  var offset = void 0;\n  var node = void 0; // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n\n  if (rangeNode) {\n    var range = window.document.createRange();\n    var textNode = rangeNode.closest(TEXT_SELECTOR);\n    range.setStart(textNode, 0);\n    range.setEnd(nearestNode, nearestOffset);\n    node = textNode;\n    offset = range.toString().length;\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    var voidNode = parentNode.closest(VOID_SELECTOR);\n    if (!voidNode) return null;\n    rangeNode = voidNode.querySelector(RANGE_SELECTOR);\n    if (!rangeNode) return null;\n    node = rangeNode;\n    offset = node.textContent.length;\n  } // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n\n\n  if (offset == node.textContent.length && parentNode.hasAttribute(ZERO_WIDTH_ATTRIBUTE)) {\n    offset--;\n  } // Get the string value of the offset key attribute.\n\n\n  var offsetKey = rangeNode.getAttribute(OFFSET_KEY_ATTRIBUTE);\n  if (!offsetKey) return null;\n\n  var _OffsetKey$parse = OffsetKey.parse(offsetKey),\n      key = _OffsetKey$parse.key; // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n\n\n  if (!value.document.hasDescendant(key)) return null;\n  return {\n    key: key,\n    offset: offset\n  };\n}\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType == 1 && node.childNodes.length) {\n    var isLast = offset == node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (node.nodeType == 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return {\n    node: node,\n    offset: offset\n  };\n}\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (child.nodeType == 8 || child.nodeType == 1 && child.childNodes.length == 0 || child.nodeType == 1 && child.getAttribute('contenteditable') == 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction == 'forward') i++;\n    if (direction == 'backward') i--;\n  }\n\n  return child || null;\n}\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Value} value\n * @return {Range}\n */\n\n\nfunction findRange(native, value) {\n  var el = native.anchorNode || native.startContainer;\n  if (!el) return null;\n  var window = getWindow(el); // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n\n  if (native instanceof window.Range || window.StaticRange && native instanceof window.StaticRange) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset\n    };\n  }\n\n  var _native = native,\n      anchorNode = _native.anchorNode,\n      anchorOffset = _native.anchorOffset,\n      focusNode = _native.focusNode,\n      focusOffset = _native.focusOffset,\n      isCollapsed = _native.isCollapsed;\n  var anchor = findPoint(anchorNode, anchorOffset, value);\n  var focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, value);\n  if (!anchor || !focus) return null; // COMPAT: ??? The Edge browser seems to have a case where if you select the\n  // last word of a span, it sets the endContainer to the containing span.\n  // `selection-is-backward` doesn't handle this case.\n\n  if (IS_IE || IS_EDGE) {\n    var domAnchor = findDOMPoint(anchor.key, anchor.offset);\n    var domFocus = findDOMPoint(focus.key, focus.offset);\n    native = {\n      anchorNode: domAnchor.node,\n      anchorOffset: domAnchor.offset,\n      focusNode: domFocus.node,\n      focusOffset: domFocus.offset\n    };\n  }\n\n  var range = Range.create({\n    anchorKey: anchor.key,\n    anchorOffset: anchor.offset,\n    focusKey: focus.key,\n    focusOffset: focus.offset,\n    isBackward: isCollapsed ? false : isBackward(native),\n    isFocused: true\n  });\n  return range;\n}\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\n\nvar OVERFLOWS = ['auto', 'overlay', 'scroll'];\n/**\n * Detect whether we are running IOS version 11\n */\n\nvar IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  var parent = el.parentNode;\n  var scroller = void 0;\n\n  while (!scroller) {\n    if (!parent.parentNode) break;\n    var style = window.getComputedStyle(parent);\n    var overflowY = style.overflowY;\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent;\n      break;\n    }\n\n    parent = parent.parentNode;\n  } // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n\n\n  if (!scroller) {\n    return window.document.body;\n  }\n\n  return scroller;\n}\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return;\n  if (!selection.anchorNode) return;\n  var window = getWindow(selection.anchorNode);\n  var scroller = findScrollContainer(selection.anchorNode, window);\n  var isWindow = scroller == window.document.body || scroller == window.document.documentElement;\n  var backward = isBackward(selection);\n  var range = selection.getRangeAt(0).cloneRange();\n  range.collapse(backward);\n  var cursorRect = range.getBoundingClientRect(); // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top == 0 && cursorRect.height == 0) {\n      if (range.startOffset == 0) {\n        range.setEnd(range.endContainer, 1);\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1);\n      }\n\n      cursorRect = range.getBoundingClientRect();\n\n      if (cursorRect.top == 0 && cursorRect.height == 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0];\n        }\n      }\n    }\n  }\n\n  var width = void 0;\n  var height = void 0;\n  var yOffset = void 0;\n  var xOffset = void 0;\n  var scrollerTop = 0;\n  var scrollerLeft = 0;\n  var scrollerBordersY = 0;\n  var scrollerBordersX = 0;\n  var scrollerPaddingTop = 0;\n  var scrollerPaddingBottom = 0;\n  var scrollerPaddingLeft = 0;\n  var scrollerPaddingRight = 0;\n\n  if (isWindow) {\n    var innerWidth = window.innerWidth,\n        innerHeight = window.innerHeight,\n        pageYOffset = window.pageYOffset,\n        pageXOffset = window.pageXOffset;\n    width = innerWidth;\n    height = innerHeight;\n    yOffset = pageYOffset;\n    xOffset = pageXOffset;\n  } else {\n    var offsetWidth = scroller.offsetWidth,\n        offsetHeight = scroller.offsetHeight,\n        scrollTop = scroller.scrollTop,\n        scrollLeft = scroller.scrollLeft;\n\n    var _window$getComputedSt = window.getComputedStyle(scroller),\n        borderTopWidth = _window$getComputedSt.borderTopWidth,\n        borderBottomWidth = _window$getComputedSt.borderBottomWidth,\n        borderLeftWidth = _window$getComputedSt.borderLeftWidth,\n        borderRightWidth = _window$getComputedSt.borderRightWidth,\n        paddingTop = _window$getComputedSt.paddingTop,\n        paddingBottom = _window$getComputedSt.paddingBottom,\n        paddingLeft = _window$getComputedSt.paddingLeft,\n        paddingRight = _window$getComputedSt.paddingRight;\n\n    var scrollerRect = scroller.getBoundingClientRect();\n    width = offsetWidth;\n    height = offsetHeight;\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\n    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\n    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\n    scrollerPaddingTop = parseInt(paddingTop, 10);\n    scrollerPaddingBottom = parseInt(paddingBottom, 10);\n    scrollerPaddingLeft = parseInt(paddingLeft, 10);\n    scrollerPaddingRight = parseInt(paddingRight, 10);\n    yOffset = scrollTop;\n    xOffset = scrollLeft;\n  }\n\n  var cursorTop = cursorRect.top + yOffset - scrollerTop;\n  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;\n  var x = xOffset;\n  var y = yOffset;\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft;\n  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop;\n  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\n    // selection below viewport\n    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y);\n  } else {\n    scroller.scrollTop = y;\n    scroller.scrollLeft = x;\n  }\n}\n/**\n * COMPAT: if we are in <= IE11 and the selection contains\n * tables, `removeAllRanges()` will throw\n * \"unable to complete the operation due to error 800a025e\"\n *\n * @param {Selection} selection document selection\n */\n\n\nfunction removeAllRanges(selection) {\n  var doc = window.document;\n\n  if (doc && doc.body.createTextRange) {\n    // All IE but Edge\n    var range = doc.body.createTextRange();\n    range.collapse();\n    range.select();\n  } else {\n    selection.removeAllRanges();\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$4 = Debug('slate:content');\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  inherits(Content, _React$Component);\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  function Content(props) {\n    classCallCheck(this, Content);\n\n    var _this = possibleConstructorReturn(this, (Content.__proto__ || Object.getPrototypeOf(Content)).call(this, props));\n\n    _this.componentDidMount = function () {\n      var window = getWindow(_this.element);\n      window.document.addEventListener('selectionchange', _this.onNativeSelectionChange); // COMPAT: Restrict scope of `beforeinput` to mobile.\n\n      if ((IS_IOS || IS_ANDROID) && SUPPORTED_EVENTS.beforeinput) {\n        _this.element.addEventListener('beforeinput', _this.onNativeBeforeInput);\n      }\n\n      _this.updateSelection();\n    };\n\n    _this.componentDidUpdate = function () {\n      _this.updateSelection();\n    };\n\n    _this.updateSelection = function () {\n      var editor = _this.props.editor;\n      var value = editor.value;\n      var selection = value.selection;\n      var isBackward$$1 = selection.isBackward;\n      var window = getWindow(_this.element);\n      var native = window.getSelection();\n      var rangeCount = native.rangeCount,\n          anchorNode = native.anchorNode; // If both selections are blurred, do nothing.\n\n      if (!rangeCount && selection.isBlurred) return; // If the selection has been blurred, but is still inside the editor in the\n      // DOM, blur it manually.\n\n      if (selection.isBlurred) {\n        if (!_this.isInEditor(anchorNode)) return;\n        removeAllRanges(native);\n\n        _this.element.blur();\n\n        debug$4('updateSelection', {\n          selection: selection,\n          native: native\n        });\n        return;\n      } // If the selection isn't set, do nothing.\n\n\n      if (selection.isUnset) return; // Otherwise, figure out which DOM nodes should be selected...\n\n      var current = !!rangeCount && native.getRangeAt(0);\n      var range = findDOMRange(selection, window);\n\n      if (!range) {\n        logger.error('Unable to find a native DOM range from the current selection.', {\n          selection: selection\n        });\n        return;\n      }\n\n      var startContainer = range.startContainer,\n          startOffset = range.startOffset,\n          endContainer = range.endContainer,\n          endOffset = range.endOffset; // If the new range matches the current selection, there is nothing to fix.\n      // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n      // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n      // to check both orientations here. (2017/10/31)\n\n      if (current) {\n        if (startContainer == current.startContainer && startOffset == current.startOffset && endContainer == current.endContainer && endOffset == current.endOffset || startContainer == current.endContainer && startOffset == current.endOffset && endContainer == current.startContainer && endOffset == current.startOffset) {\n          return;\n        }\n      } // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n\n\n      _this.tmp.isUpdatingSelection = true;\n      removeAllRanges(native); // COMPAT: IE 11 does not support Selection.setBaseAndExtent\n\n      if (native.setBaseAndExtent) {\n        // COMPAT: Since the DOM range has no concept of backwards/forwards\n        // we need to check and do the right thing here.\n        if (isBackward$$1) {\n          native.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\n        } else {\n          native.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n        }\n      } else {\n        // COMPAT: IE 11 does not support Selection.extend, fallback to addRange\n        native.addRange(range);\n      } // Scroll to the selection, in case it's out of view.\n\n\n      scrollToSelection(native); // Then unset the `isUpdatingSelection` flag after a delay.\n\n      setTimeout(function () {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need to\n        // focus the contenteditable element too. (2016/11/16)\n        if (IS_FIREFOX && _this.element) _this.element.focus();\n        _this.tmp.isUpdatingSelection = false;\n      });\n      debug$4('updateSelection', {\n        selection: selection,\n        native: native\n      });\n    };\n\n    _this.ref = function (element) {\n      _this.element = element;\n    };\n\n    _this.isInEditor = function (target) {\n      var element = _this.element; // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n\n      var el = target.nodeType === 3 ? target.parentNode : target;\n      return el.isContentEditable && (el === element || el.closest('[data-slate-editor]') === element);\n    };\n\n    _this.onNativeBeforeInput = function (event) {\n      if (_this.props.readOnly) return;\n      if (!_this.isInEditor(event.target)) return;\n\n      var _event$getTargetRange = event.getTargetRanges(),\n          _event$getTargetRange2 = slicedToArray(_event$getTargetRange, 1),\n          targetRange = _event$getTargetRange2[0];\n\n      if (!targetRange) return;\n      var editor = _this.props.editor;\n\n      switch (event.inputType) {\n        case 'deleteContentBackward':\n          {\n            event.preventDefault();\n            var range = findRange(targetRange, editor.value);\n            editor.change(function (change) {\n              return change.deleteAtRange(range);\n            });\n            break;\n          }\n\n        case 'insertLineBreak': // intentional fallthru\n\n        case 'insertParagraph':\n          {\n            event.preventDefault();\n\n            var _range = findRange(targetRange, editor.value);\n\n            editor.change(function (change) {\n              if (change.value.isInVoid) {\n                change.collapseToStartOfNextText();\n              } else {\n                change.splitBlockAtRange(_range);\n              }\n            });\n            break;\n          }\n\n        case 'insertReplacementText': // intentional fallthru\n\n        case 'insertText':\n          {\n            // `data` should have the text for the `insertText` input type and\n            // `dataTransfer` should have the text for the `insertReplacementText`\n            // input type, but Safari uses `insertText` for spell check replacements\n            // and sets `data` to `null`.\n            var text = event.data == null ? event.dataTransfer.getData('text/plain') : event.data;\n            if (text == null) return;\n            event.preventDefault();\n            var value = editor.value;\n            var selection = value.selection;\n\n            var _range2 = findRange(targetRange, value);\n\n            editor.change(function (change) {\n              change.insertTextAtRange(_range2, text, selection.marks); // If the text was successfully inserted, and the selection had marks\n              // on it, unset the selection's marks.\n\n              if (selection.marks && value.document != change.value.document) {\n                change.select({\n                  marks: null\n                });\n              }\n            });\n            break;\n          }\n      }\n    };\n\n    _this.onNativeSelectionChange = throttle(function (event) {\n      if (_this.props.readOnly) return;\n      var window = getWindow(event.target);\n      var activeElement = window.document.activeElement;\n      if (activeElement !== _this.element) return;\n\n      _this.props.onSelect(event);\n    }, 100);\n\n    _this.renderNode = function (child, isSelected, decorations) {\n      var _this$props = _this.props,\n          editor = _this$props.editor,\n          readOnly = _this$props.readOnly;\n      var value = editor.value;\n      var document = value.document,\n          isFocused = value.isFocused;\n      return React.createElement(Node$1, {\n        block: null,\n        editor: editor,\n        decorations: decorations,\n        isSelected: isSelected,\n        isFocused: isFocused && isSelected,\n        key: child.key,\n        node: child,\n        parent: document,\n        readOnly: readOnly\n      });\n    };\n\n    _this.tmp = {};\n    _this.tmp.isUpdatingSelection = false;\n    EVENT_HANDLERS.forEach(function (handler) {\n      _this[handler] = function (event) {\n        _this.onEvent(handler, event);\n      };\n    });\n    return _this;\n  }\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Content, [{\n    key: 'componentWillUnmount',\n\n    /**\n     * When unmounting, remove DOM event listeners.\n     */\n    value: function componentWillUnmount() {\n      var window = getWindow(this.element);\n\n      if (window) {\n        window.document.removeEventListener('selectionchange', this.onNativeSelectionChange);\n      } // COMPAT: Restrict scope of `beforeinput` to mobile.\n\n\n      if ((IS_IOS || IS_ANDROID) && SUPPORTED_EVENTS.beforeinput) {\n        this.element.removeEventListener('beforeinput', this.onNativeBeforeInput);\n      }\n    }\n    /**\n     * On update, update the selection.\n     */\n\n    /**\n     * Update the native DOM selection to reflect the internal model.\n     */\n\n    /**\n     * The React ref method to set the root content element locally.\n     *\n     * @param {Element} element\n     */\n\n    /**\n     * Check if an event `target` is fired from within the contenteditable\n     * element. This should be false for edits happening in non-contenteditable\n     * children, such as void nodes and other nested Slate editors.\n     *\n     * @param {Element} target\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'onEvent',\n\n    /**\n     * On `event` with `handler`.\n     *\n     * @param {String} handler\n     * @param {Event} event\n     */\n    value: function onEvent(handler, event) {\n      debug$4('onEvent', handler); // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n      // programmatically while updating selection.\n\n      if (this.tmp.isUpdatingSelection && (handler == 'onSelect' || handler == 'onBlur' || handler == 'onFocus')) {\n        return;\n      } // COMPAT: There are situations where a select event will fire with a new\n      // native selection that resolves to the same internal position. In those\n      // cases we don't need to trigger any changes, since our internal model is\n      // already up to date, but we do want to update the native selection again\n      // to make sure it is in sync. (2017/10/16)\n\n\n      if (handler == 'onSelect') {\n        var editor = this.props.editor;\n        var value = editor.value;\n        var selection = value.selection;\n        var window = getWindow(event.target);\n        var native = window.getSelection();\n        var range = findRange(native, value);\n\n        if (range && range.equals(selection)) {\n          this.updateSelection();\n          return;\n        }\n      } // Don't handle drag and drop events coming from embedded editors.\n\n\n      if (handler == 'onDragEnd' || handler == 'onDragEnter' || handler == 'onDragExit' || handler == 'onDragLeave' || handler == 'onDragOver' || handler == 'onDragStart' || handler == 'onDrop') {\n        var target = event.target;\n        var targetEditorNode = target.closest('[data-slate-editor]');\n        if (targetEditorNode !== this.element) return;\n      } // Some events require being in editable in the editor, so if the event\n      // target isn't, ignore them.\n\n\n      if (handler == 'onBeforeInput' || handler == 'onBlur' || handler == 'onCompositionEnd' || handler == 'onCompositionStart' || handler == 'onCopy' || handler == 'onCut' || handler == 'onFocus' || handler == 'onInput' || handler == 'onKeyDown' || handler == 'onKeyUp' || handler == 'onPaste' || handler == 'onSelect') {\n        if (!this.isInEditor(event.target)) return;\n      }\n\n      this.props[handler](event);\n    }\n    /**\n     * On a native `beforeinput` event, use the additional range information\n     * provided by the event to manipulate text exactly as the browser would.\n     *\n     * This is currently only used on iOS and Android.\n     *\n     * @param {InputEvent} event\n     */\n\n    /**\n     * On native `selectionchange` event, trigger the `onSelect` handler. This is\n     * needed to account for React's `onSelect` being non-standard and not firing\n     * until after a selection has been released. This causes issues in situations\n     * where another change happens while a selection is being made.\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: 'render',\n\n    /**\n     * Render the editor content.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _this2 = this;\n\n      var props = this.props;\n      var className = props.className,\n          readOnly = props.readOnly,\n          editor = props.editor,\n          tabIndex = props.tabIndex,\n          role = props.role,\n          tagName = props.tagName,\n          spellCheck = props.spellCheck;\n      var value = editor.value,\n          stack = editor.stack;\n      var Container = tagName;\n      var document = value.document,\n          selection = value.selection,\n          decorations = value.decorations;\n      var indexes = document.getSelectionIndexes(selection);\n      var decs = document.getDecorations(stack).concat(decorations || []);\n      var childrenDecorations = getChildrenDecorations(document, decs);\n      var children = document.nodes.toArray().map(function (child, i) {\n        var isSelected = !!indexes && indexes.start <= i && i < indexes.end;\n        return _this2.renderNode(child, isSelected, childrenDecorations[i]);\n      });\n      var handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\n        obj[handler] = _this2[handler];\n        return obj;\n      }, {});\n\n      var style = _extends({\n        // Prevent the default outline styles.\n        outline: 'none',\n        // Preserve adjacent whitespace and new lines.\n        whiteSpace: 'pre-wrap',\n        // Allow words to break if they are too long.\n        wordWrap: 'break-word'\n      }, readOnly ? {} : {\n        WebkitUserModify: 'read-write-plaintext-only'\n      }, props.style);\n\n      debug$4('render', {\n        props: props\n      });\n      return React.createElement(Container, _extends({}, handlers, {\n        'data-slate-editor': true,\n        ref: this.ref,\n        'data-key': document.key,\n        contentEditable: readOnly ? null : true,\n        suppressContentEditableWarning: true,\n        className: className,\n        onBlur: this.onBlur,\n        onFocus: this.onFocus,\n        onCompositionEnd: this.onCompositionEnd,\n        onCompositionStart: this.onCompositionStart,\n        onCopy: this.onCopy,\n        onCut: this.onCut,\n        onDragEnd: this.onDragEnd,\n        onDragOver: this.onDragOver,\n        onDragStart: this.onDragStart,\n        onDrop: this.onDrop,\n        onInput: this.onInput,\n        onKeyDown: this.onKeyDown,\n        onKeyUp: this.onKeyUp,\n        onPaste: this.onPaste,\n        onSelect: this.onSelect,\n        autoCorrect: props.autoCorrect ? 'on' : 'off',\n        spellCheck: spellCheck,\n        style: style,\n        role: readOnly ? null : role || 'textbox',\n        tabIndex: tabIndex // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        ,\n        'data-gramm': false\n      }), children, this.props.children);\n    }\n    /**\n     * Render a `child` node of the document.\n     *\n     * @param {Node} child\n     * @param {Boolean} isSelected\n     * @return {Element}\n     */\n\n  }]);\n  return Content;\n}(React.Component);\n/**\n * Mix in handler prop types.\n */\n\n\nContent.propTypes = {\n  autoCorrect: Types.bool.isRequired,\n  children: Types.any.isRequired,\n  className: Types.string,\n  editor: Types.object.isRequired,\n  readOnly: Types.bool.isRequired,\n  role: Types.string,\n  spellCheck: Types.bool.isRequired,\n  style: Types.object,\n  tabIndex: Types.number,\n  tagName: Types.string\n};\nContent.defaultProps = {\n  style: {},\n  tagName: 'div'\n};\nEVENT_HANDLERS.forEach(function (handler) {\n  Content.propTypes[handler] = Types.func.isRequired;\n});\n/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nvar TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain'\n  /**\n   * Export.\n   *\n   * @type {Object}\n   */\n\n};\nvar FRAGMENT = TRANSFER_TYPES.FRAGMENT;\nvar HTML = TRANSFER_TYPES.HTML;\nvar TEXT = TRANSFER_TYPES.TEXT;\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Value} value\n * @param {Document} [fragment]\n */\n\nfunction cloneFragment(event, value) {\n  var fragment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : value.fragment;\n  var window = getWindow(event.target);\n  var native = window.getSelection();\n  var startKey = value.startKey,\n      endKey = value.endKey;\n  var startVoid = value.document.getClosestVoid(startKey);\n  var endVoid = value.document.getClosestVoid(endKey); // If the selection is collapsed, and it isn't inside a void node, abort.\n\n  if (native.isCollapsed && !startVoid) return; // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n\n  var encoded = Base64.serializeNode(fragment);\n  var range = native.getRangeAt(0);\n  var contents = range.cloneContents();\n  var attach = contents.childNodes[0]; // Make sure attach is a non-empty node, since empty nodes will not get copied\n\n  contents.childNodes.forEach(function (node) {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node;\n    }\n  }); // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n\n  if (endVoid) {\n    var r = range.cloneRange();\n    var node = findDOMNode$1(endVoid, window);\n    r.setEndAfter(node);\n    contents = r.cloneContents();\n  } // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n\n\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild;\n  } // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n\n\n  [].slice.call(contents.querySelectorAll(ZERO_WIDTH_SELECTOR)).forEach(function (zw) {\n    var isNewline = zw.getAttribute(ZERO_WIDTH_ATTRIBUTE) === 'n';\n    zw.textContent = isNewline ? '\\n' : '';\n  }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n  if (attach.nodeType == 3) {\n    var span = window.document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n\n    span.style.whiteSpace = 'pre';\n    span.appendChild(attach);\n    contents.appendChild(span);\n    attach = span;\n  }\n\n  attach.setAttribute('data-slate-fragment', encoded); // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n\n  var div = window.document.createElement('div');\n  div.appendChild(contents); // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault();\n    event.clipboardData.setData(TEXT, div.textContent);\n    event.clipboardData.setData(FRAGMENT, encoded);\n    event.clipboardData.setData(HTML, div.innerHTML);\n    return;\n  } // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n\n\n  var editor = event.target.closest('[data-slate-editor]');\n  div.setAttribute('contenteditable', true);\n  div.style.position = 'absolute';\n  div.style.left = '-9999px';\n  editor.appendChild(div);\n  native.selectAllChildren(div); // Revert to the previous selection right after copying.\n\n  window.requestAnimationFrame(function () {\n    editor.removeChild(div);\n    removeAllRanges(native);\n    native.addRange(range);\n  });\n}\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Value} value\n * @return {Node|Null}\n */\n\n\nfunction findNode(element, value) {\n  var closest = element.closest('[data-key]');\n  if (!closest) return null;\n  var key = closest.getAttribute('data-key');\n  if (!key) return null;\n  var node = value.document.getNode(key);\n  return node || null;\n}\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Value} value\n * @return {Range}\n */\n\n\nfunction getEventRange(event, value) {\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var _event = event,\n      x = _event.x,\n      y = _event.y,\n      target = _event.target;\n  if (x == null || y == null) return null;\n  var document = value.document;\n  var node = findNode(target, value);\n  if (!node) return null; // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n\n  if (node.isVoid) {\n    var rect = target.getBoundingClientRect();\n    var isPrevious = node.object == 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n    var text = node.getFirstText();\n\n    var _range = Range.create();\n\n    if (isPrevious) {\n      var previousText = document.getPreviousText(text.key);\n\n      if (previousText) {\n        return _range.moveToEndOf(previousText);\n      }\n    }\n\n    var nextText = document.getNextText(text.key);\n    return nextText ? _range.moveToStartOf(nextText) : null;\n  } // Else resolve a range from the caret position where the drop occured.\n\n\n  var window = getWindow(target);\n  var native = void 0; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y);\n  } else if (window.document.caretPositionFromPoint) {\n    var position = window.document.caretPositionFromPoint(x, y);\n    native = window.document.createRange();\n    native.setStart(position.offsetNode, position.offset);\n    native.setEnd(position.offsetNode, position.offset);\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange();\n\n    try {\n      native.moveToPoint(x, y);\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null;\n    }\n  } // Resolve a Slate range from the DOM range.\n\n\n  var range = findRange(native, value);\n  if (!range) return null;\n  return range;\n}\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\n\nvar FRAGMENT$1 = TRANSFER_TYPES.FRAGMENT;\nvar HTML$1 = TRANSFER_TYPES.HTML;\nvar NODE = TRANSFER_TYPES.NODE;\nvar RICH = TRANSFER_TYPES.RICH;\nvar TEXT$1 = TRANSFER_TYPES.TEXT;\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n  var fragment = getType(transfer, FRAGMENT$1);\n  var node = getType(transfer, NODE);\n  var html = getType(transfer, HTML$1);\n  var rich = getType(transfer, RICH);\n  var text = getType(transfer, TEXT$1);\n  var files = void 0; // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n\n  if (!fragment && html && ~html.indexOf(' data-slate-fragment=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  } // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n\n\n  if (text) {\n    var embeddedTypes = getEmbeddedTypes(text);\n    if (embeddedTypes[FRAGMENT$1]) fragment = embeddedTypes[FRAGMENT$1];\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE];\n    if (embeddedTypes[TEXT$1]) text = embeddedTypes[TEXT$1];\n  } // Decode a fragment or node if they exist.\n\n\n  if (fragment) fragment = Base64.deserializeNode(fragment);\n  if (node) node = Base64.deserializeNode(node); // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items).map(function (item) {\n        return item.kind == 'file' ? item.getAsFile() : null;\n      }).filter(function (exists) {\n        return exists;\n      });\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } // Determine the type of the data.\n\n\n  var data = {\n    files: files,\n    fragment: fragment,\n    html: html,\n    node: node,\n    rich: rich,\n    text: text\n  };\n  data.type = getTransferType(data);\n  return data;\n}\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\n\nfunction getEmbeddedTypes(text) {\n  var prefix = 'SLATE-DATA-EMBED::';\n\n  if (text.substring(0, prefix.length) != prefix) {\n    return {\n      TEXT: text\n    };\n  } // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n\n\n  try {\n    return JSON.parse(text.substring(prefix.length));\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.');\n  }\n}\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node'; // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type == TEXT$1 ? transfer.getData('Text') || null : null;\n  } // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n\n\n  var types = Array.from(transfer.types);\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\n\nvar TEXT$2 = TRANSFER_TYPES.TEXT;\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  var mime = TRANSFER_TYPES[type.toUpperCase()];\n\n  if (!mime) {\n    throw new Error('Cannot set unknown transfer type \"' + mime + '\".');\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n\n  try {\n    transfer.setData(mime, content); // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n\n    transfer.setData('text', transfer.getData('text'));\n  } catch (err) {\n    var prefix = 'SLATE-DATA-EMBED::';\n    var text = transfer.getData(TEXT$2);\n    var obj = {}; // If the existing plain text data is prefixed, it's Slate JSON data.\n\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length));\n      } catch (e) {\n        throw new Error('Failed to parse Slate data from `DataTransfer` object.');\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT$2] = text;\n    }\n\n    obj[mime] = content;\n    var string = '' + prefix + JSON.stringify(obj);\n    transfer.setData(TEXT$2, string);\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$5 = Debug('slate:after');\n/**\n * The after plugin.\n *\n * @return {Object}\n */\n\nfunction AfterPlugin() {\n  var isDraggingInternally = null;\n  /**\n   * On before input, correct any browser inconsistencies.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onBeforeInput(event, change, editor) {\n    debug$5('onBeforeInput', {\n      event: event\n    });\n    event.preventDefault();\n    change.insertText(event.data);\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onBlur(event, change, editor) {\n    debug$5('onBlur', {\n      event: event\n    });\n    change.blur();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onClick(event, change, editor) {\n    if (editor.props.readOnly) return true;\n    var value = change.value;\n    var document = value.document;\n    var node = findNode(event.target, value);\n    var isVoid = node && (node.isVoid || document.hasVoidParent(node.key));\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      change.focus().collapseToEndOf(node);\n    }\n\n    debug$5('onClick', {\n      event: event\n    });\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onCopy(event, change, editor) {\n    debug$5('onCopy', {\n      event: event\n    });\n    cloneFragment(event, change.value);\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onCut(event, change, editor) {\n    debug$5('onCut', {\n      event: event\n    });\n    cloneFragment(event, change.value);\n    var window = getWindow(event.target); // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n\n    window.requestAnimationFrame(function () {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      var value = change.value;\n      var endBlock = value.endBlock,\n          endInline = value.endInline,\n          isCollapsed = value.isCollapsed;\n      var isVoidBlock = endBlock && endBlock.isVoid && isCollapsed;\n      var isVoidInline = endInline && endInline.isVoid && isCollapsed;\n\n      if (isVoidBlock) {\n        editor.change(function (c) {\n          return c.removeNodeByKey(endBlock.key);\n        });\n      } else if (isVoidInline) {\n        editor.change(function (c) {\n          return c.removeNodeByKey(endInline.key);\n        });\n      } else {\n        editor.change(function (c) {\n          return c.delete();\n        });\n      }\n    });\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragEnd(event, change, editor) {\n    debug$5('onDragEnd', {\n      event: event\n    });\n    isDraggingInternally = null;\n  }\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragOver(event, change, editor) {\n    debug$5('onDragOver', {\n      event: event\n    });\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragStart(event, change, editor) {\n    debug$5('onDragStart', {\n      event: event\n    });\n    isDraggingInternally = true;\n    var value = change.value;\n    var document = value.document;\n    var node = findNode(event.target, value);\n    var isVoid = node && (node.isVoid || document.hasVoidParent(node.key));\n\n    if (isVoid) {\n      var encoded = Base64.serializeNode(node, {\n        preserveKeys: true\n      });\n      setEventTransfer(event, 'node', encoded);\n    } else {\n      var fragment = value.fragment;\n\n      var _encoded = Base64.serializeNode(fragment);\n\n      setEventTransfer(event, 'fragment', _encoded);\n    }\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDrop(event, change, editor) {\n    debug$5('onDrop', {\n      event: event\n    });\n    var value = change.value;\n    var document = value.document,\n        selection = value.selection;\n    var window = getWindow(event.target);\n    var target = getEventRange(event, value);\n    if (!target) return;\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        node = transfer.node,\n        text = transfer.text;\n    change.focus(); // If the drag is internal and the target is after the selection, it\n    // needs to account for the selection's content being deleted.\n\n    if (isDraggingInternally && selection.endKey == target.endKey && selection.endOffset < target.endOffset) {\n      target = target.move(selection.startKey == selection.endKey ? 0 - selection.endOffset + selection.startOffset : 0 - selection.endOffset);\n    }\n\n    if (isDraggingInternally) {\n      change.delete();\n    }\n\n    change.select(target);\n\n    if (type == 'text' || type == 'html') {\n      var _target = target,\n          anchorKey = _target.anchorKey;\n      var hasVoidParent = document.hasVoidParent(anchorKey);\n\n      if (hasVoidParent) {\n        var n = document.getNode(anchorKey);\n\n        while (hasVoidParent) {\n          n = document.getNextText(n.key);\n          if (!n) break;\n          hasVoidParent = document.hasVoidParent(n.key);\n        }\n\n        if (n) change.collapseToStartOf(n);\n      }\n\n      if (text) {\n        text.split('\\n').forEach(function (line, i) {\n          if (i > 0) change.splitBlock();\n          change.insertText(line);\n        });\n      }\n    }\n\n    if (type == 'fragment') {\n      change.insertFragment(fragment);\n    }\n\n    if (type == 'node' && Block.isBlock(node)) {\n      change.insertBlock(node.regenerateKey()).removeNodeByKey(node.key);\n    }\n\n    if (type == 'node' && Inline.isInline(node)) {\n      change.insertInline(node.regenerateKey()).removeNodeByKey(node.key);\n    } // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n\n\n    var focusNode = document.getNode(target.focusKey);\n    var el = findDOMNode$1(focusNode, window);\n    if (!el) return;\n    el.dispatchEvent(new MouseEvent('mouseup', {\n      view: window,\n      bubbles: true,\n      cancelable: true\n    }));\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} eventvent\n   * @param {Change} change\n   */\n\n\n  function onInput(event, change, editor) {\n    debug$5('onInput', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var value = change.value; // Get the selection point.\n\n    var native = window.getSelection();\n    var anchorNode = native.anchorNode;\n    var point = findPoint(anchorNode, 0, value);\n    if (!point) return; // Get the text node and leaf in question.\n\n    var document = value.document,\n        selection = value.selection;\n    var node = document.getDescendant(point.key);\n    var block = document.getClosestBlock(node.key);\n    var leaves = node.getLeaves();\n    var lastText = block.getLastText();\n    var lastLeaf = leaves.last();\n    var start = 0;\n    var end = 0;\n    var leaf = leaves.find(function (r) {\n      start = end;\n      end += r.text.length;\n      if (end > point.offset) return true;\n    }) || lastLeaf; // Get the text information.\n\n    var text = leaf.text;\n    var textContent = anchorNode.textContent;\n    var isLastText = node == lastText;\n    var isLastLeaf = leaf == lastLeaf;\n    var lastChar = textContent.charAt(textContent.length - 1); // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n\n    if (isLastText && isLastLeaf && lastChar == '\\n') {\n      textContent = textContent.slice(0, -1);\n    } // If the text is no different, abort.\n\n\n    if (textContent == text) return; // Determine what the selection should be after changing the text.\n\n    var delta = textContent.length - text.length;\n    var corrected = selection.collapseToEnd().move(delta);\n    var entire = selection.moveAnchorTo(point.key, start).moveFocusTo(point.key, end); // Change the current value to have the leaf's text replaced.\n\n    change.insertTextAtRange(entire, textContent, leaf.marks).select(corrected);\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onKeyDown(event, change, editor) {\n    debug$5('onKeyDown', {\n      event: event\n    });\n    var value = change.value; // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return value.isInVoid ? change.collapseToStartOfNextText() : change.splitBlock();\n    }\n\n    if (Hotkeys.isDeleteCharBackward(event) && !IS_IOS) {\n      return change.deleteCharBackward();\n    }\n\n    if (Hotkeys.isDeleteCharForward(event) && !IS_IOS) {\n      return change.deleteCharForward();\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return change.deleteLineBackward();\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return change.deleteLineForward();\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return change.deleteWordBackward();\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return change.deleteWordForward();\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return change.redo();\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return change.undo();\n    } // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n\n\n    if (Hotkeys.isCollapseLineBackward(event)) {\n      event.preventDefault();\n      return change.collapseLineBackward();\n    }\n\n    if (Hotkeys.isCollapseLineForward(event)) {\n      event.preventDefault();\n      return change.collapseLineForward();\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault();\n      return change.extendLineBackward();\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault();\n      return change.extendLineForward();\n    } // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n\n\n    if (Hotkeys.isCollapseCharBackward(event)) {\n      var document = value.document,\n          isInVoid = value.isInVoid,\n          previousText = value.previousText,\n          startText = value.startText;\n      var isPreviousInVoid = previousText && document.hasVoidParent(previousText.key);\n\n      if (isInVoid || isPreviousInVoid || startText.text == '') {\n        event.preventDefault();\n        return change.collapseCharBackward();\n      }\n    }\n\n    if (Hotkeys.isCollapseCharForward(event)) {\n      var _document = value.document,\n          _isInVoid = value.isInVoid,\n          nextText = value.nextText,\n          _startText = value.startText;\n\n      var isNextInVoid = nextText && _document.hasVoidParent(nextText.key);\n\n      if (_isInVoid || isNextInVoid || _startText.text == '') {\n        event.preventDefault();\n        return change.collapseCharForward();\n      }\n    }\n\n    if (Hotkeys.isExtendCharBackward(event)) {\n      var _document2 = value.document,\n          _isInVoid2 = value.isInVoid,\n          _previousText = value.previousText,\n          _startText2 = value.startText;\n\n      var _isPreviousInVoid = _previousText && _document2.hasVoidParent(_previousText.key);\n\n      if (_isInVoid2 || _isPreviousInVoid || _startText2.text == '') {\n        event.preventDefault();\n        return change.extendCharBackward();\n      }\n    }\n\n    if (Hotkeys.isExtendCharForward(event)) {\n      var _document3 = value.document,\n          _isInVoid3 = value.isInVoid,\n          _nextText = value.nextText,\n          _startText3 = value.startText;\n\n      var _isNextInVoid = _nextText && _document3.hasVoidParent(_nextText.key);\n\n      if (_isInVoid3 || _isNextInVoid || _startText3.text == '') {\n        event.preventDefault();\n        return change.extendCharForward();\n      }\n    }\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onPaste(event, change, editor) {\n    debug$5('onPaste', {\n      event: event\n    });\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n\n    if (type == 'fragment') {\n      change.insertFragment(fragment);\n    }\n\n    if (type == 'text' || type == 'html') {\n      if (!text) return;\n      var value = change.value;\n      var document = value.document,\n          selection = value.selection,\n          startBlock = value.startBlock;\n      if (startBlock.isVoid) return;\n      var defaultBlock = startBlock;\n      var defaultMarks = document.getInsertMarksAtRange(selection);\n      var frag = Plain.deserialize(text, {\n        defaultBlock: defaultBlock,\n        defaultMarks: defaultMarks\n      }).document;\n      change.insertFragment(frag);\n    }\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onSelect(event, change, editor) {\n    debug$5('onSelect', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var value = change.value;\n    var document = value.document;\n    var native = window.getSelection(); // If there are no ranges, the editor was blurred natively.\n\n    if (!native.rangeCount) {\n      change.blur();\n      return;\n    } // Otherwise, determine the Slate selection from the native one.\n\n\n    var range = findRange(native, value);\n    if (!range) return;\n    var _range = range,\n        anchorKey = _range.anchorKey,\n        anchorOffset = _range.anchorOffset,\n        focusKey = _range.focusKey,\n        focusOffset = _range.focusOffset;\n    var anchorText = document.getNode(anchorKey);\n    var focusText = document.getNode(focusKey);\n    var anchorInline = document.getClosestInline(anchorKey);\n    var focusInline = document.getClosestInline(focusKey);\n    var focusBlock = document.getClosestBlock(focusKey);\n    var anchorBlock = document.getClosestBlock(anchorKey); // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n\n    if (anchorBlock && !anchorBlock.isVoid && anchorOffset == 0 && focusBlock && focusBlock.isVoid && focusOffset != 0) {\n      range = range.set('focusOffset', 0);\n    } // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n\n\n    if (anchorInline && !anchorInline.isVoid && anchorOffset == anchorText.text.length) {\n      var block = document.getClosestBlock(anchorKey);\n      var next = block.getNextText(anchorKey);\n      if (next) range = range.moveAnchorTo(next.key, 0);\n    }\n\n    if (focusInline && !focusInline.isVoid && focusOffset == focusText.text.length) {\n      var _block = document.getClosestBlock(focusKey);\n\n      var _next = _block.getNextText(focusKey);\n\n      if (_next) range = range.moveFocusTo(_next.key, 0);\n    }\n\n    range = range.normalize(document);\n    change.select(range);\n  }\n  /**\n   * Render editor.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @return {Object}\n   */\n\n\n  function renderEditor(props, editor) {\n    var handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\n      obj[handler] = editor[handler];\n      return obj;\n    }, {});\n    return React.createElement(Content, _extends({}, handlers, {\n      autoCorrect: props.autoCorrect,\n      className: props.className,\n      children: props.children,\n      editor: editor,\n      readOnly: props.readOnly,\n      role: props.role,\n      spellCheck: props.spellCheck,\n      style: props.style,\n      tabIndex: props.tabIndex,\n      tagName: props.tagName\n    }));\n  }\n  /**\n   * Render node.\n   *\n   * @param {Object} props\n   * @return {Element}\n   */\n\n\n  function renderNode(props) {\n    var attributes = props.attributes,\n        children = props.children,\n        node = props.node;\n    if (node.object != 'block' && node.object != 'inline') return;\n    var Tag = node.object == 'block' ? 'div' : 'span';\n    var style = {\n      position: 'relative'\n    };\n    return React.createElement(Tag, _extends({}, attributes, {\n      style: style\n    }), children);\n  }\n  /**\n   * Render placeholder.\n   *\n   * @param {Object} props\n   * @return {Element}\n   */\n\n\n  function renderPlaceholder(props) {\n    var editor = props.editor,\n        node = props.node;\n    if (!editor.props.placeholder) return;\n    if (editor.state.isComposing) return;\n    if (node.object != 'block') return;\n    if (!Text.isTextList(node.nodes)) return;\n    if (node.text != '') return;\n    if (editor.value.document.getBlocks().size > 1) return;\n    var style = {\n      pointerEvents: 'none',\n      display: 'inline-block',\n      width: '0',\n      maxWidth: '100%',\n      whiteSpace: 'nowrap',\n      opacity: '0.333'\n    };\n    return React.createElement('span', {\n      contentEditable: false,\n      style: style\n    }, editor.props.placeholder);\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragOver: onDragOver,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect,\n    renderEditor: renderEditor,\n    renderNode: renderNode,\n    renderPlaceholder: renderPlaceholder\n  };\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$6 = Debug('slate:before');\n/**\n * The core before plugin.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  var activeElement = null;\n  var compositionCount = 0;\n  var isComposing = false;\n  var isCopying = false;\n  var isDragging = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n  function onBeforeInput(event, change, editor) {\n    if (editor.props.readOnly) return true; // COMPAT: React's `onBeforeInput` synthetic event is based on the native\n    // `keypress` and `textInput` events. In browsers that support the native\n    // `beforeinput` event, we instead use that event to trigger text insertion,\n    // since it provides more useful information about the range being affected\n    // and also preserves compatibility with iOS autocorrect, which would be\n    // broken if we called `preventDefault()` on React's synthetic event here.\n    // Since native `onbeforeinput` mainly benefits autocorrect and spellcheck\n    // for mobile, on desktop it brings IME issue, limit its scope for now.\n\n    if ((IS_IOS || IS_ANDROID) && SUPPORTED_EVENTS.beforeinput) return true;\n    debug$6('onBeforeInput', {\n      event: event\n    });\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onBlur(event, change, editor) {\n    if (isCopying) return true;\n    if (editor.props.readOnly) return true;\n    var value = change.value;\n    var relatedTarget = event.relatedTarget,\n        target = event.target;\n    var window = getWindow(target); // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n\n    if (activeElement == window.document.activeElement) return true; // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n\n    if (relatedTarget) {\n      var el = findDOMNode(editor); // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n\n      if (relatedTarget == el) return true; // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n\n      if (relatedTarget.hasAttribute('data-slate-spacer')) return true; // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n\n      var node = findNode(relatedTarget, value);\n      if (el.contains(relatedTarget) && node && !node.isVoid) return true;\n    }\n\n    debug$6('onBlur', {\n      event: event\n    });\n  }\n  /**\n   * On change.\n   *\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onChange(change, editor) {\n    var value = change.value; // If the value's schema isn't the editor's schema, update it. This can\n    // happen on the initialization of the editor, or if the schema changes.\n    // This change isn't save into history since only schema is updated.\n\n    if (value.schema != editor.schema) {\n      change.setValue({\n        schema: editor.schema\n      }, {\n        save: false\n      }).normalize();\n    }\n\n    debug$6('onChange');\n  }\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onCompositionEnd(event, change, editor) {\n    var n = compositionCount; // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n\n    window.requestAnimationFrame(function () {\n      if (compositionCount > n) return;\n      isComposing = false; // HACK: we need to re-render the editor here so that it will update its\n      // placeholder in case one is currently rendered. This should be handled\n      // differently ideally, in a less invasive way?\n      // (apply force re-render if isComposing changes)\n\n      if (editor.state.isComposing) {\n        editor.setState({\n          isComposing: false\n        });\n      }\n    });\n    debug$6('onCompositionEnd', {\n      event: event\n    });\n  }\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onCompositionStart(event, change, editor) {\n    isComposing = true;\n    compositionCount++; // HACK: we need to re-render the editor here so that it will update its\n    // placeholder in case one is currently rendered. This should be handled\n    // differently ideally, in a less invasive way?\n    // (apply force re-render if isComposing changes)\n\n    if (!editor.state.isComposing) {\n      editor.setState({\n        isComposing: true\n      });\n    }\n\n    debug$6('onCompositionStart', {\n      event: event\n    });\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onCopy(event, change, editor) {\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$6('onCopy', {\n      event: event\n    });\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onCut(event, change, editor) {\n    if (editor.props.readOnly) return true;\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$6('onCut', {\n      event: event\n    });\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragEnd(event, change, editor) {\n    isDragging = false;\n    debug$6('onDragEnd', {\n      event: event\n    });\n  }\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragEnter(event, change, editor) {\n    debug$6('onDragEnter', {\n      event: event\n    });\n  }\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragExit(event, change, editor) {\n    debug$6('onDragExit', {\n      event: event\n    });\n  }\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragLeave(event, change, editor) {\n    debug$6('onDragLeave', {\n      event: event\n    });\n  }\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragOver(event, change, editor) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    var node = findNode(event.target, editor.value);\n    if (node.isVoid) event.preventDefault(); // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n\n    if (IS_IE) event.preventDefault(); // If a drag is already in progress, don't do this again.\n\n    if (!isDragging) {\n      isDragging = true; // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move';\n      }\n    }\n\n    debug$6('onDragOver', {\n      event: event\n    });\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDragStart(event, change, editor) {\n    isDragging = true;\n    debug$6('onDragStart', {\n      event: event\n    });\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onDrop(event, change, editor) {\n    // Nothing happens in read-only mode.\n    if (editor.props.readOnly) return true; // Prevent default so the DOM's value isn't corrupted.\n\n    event.preventDefault();\n    debug$6('onDrop', {\n      event: event\n    });\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onFocus(event, change, editor) {\n    if (isCopying) return true;\n    if (editor.props.readOnly) return true;\n    var el = findDOMNode(editor); // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n\n    if (IS_FIREFOX && event.target != el) {\n      el.focus();\n      return true;\n    }\n\n    debug$6('onFocus', {\n      event: event\n    });\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onInput(event, change, editor) {\n    if (isComposing) return true;\n    if (change.value.isBlurred) return true;\n    debug$6('onInput', {\n      event: event\n    });\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onKeyDown(event, change, editor) {\n    if (editor.props.readOnly) return true; // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n\n    if (isComposing) {\n      if (Hotkeys.isComposing(event)) event.preventDefault();\n      return true;\n    } // Certain hotkeys have native behavior in contenteditable elements which\n    // will cause our value to be out of sync, so prevent them.\n\n\n    if (Hotkeys.isContentEditable(event) && !IS_IOS) {\n      event.preventDefault();\n    }\n\n    debug$6('onKeyDown', {\n      event: event\n    });\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onPaste(event, change, editor) {\n    if (editor.props.readOnly) return true; // Prevent defaults so the DOM state isn't corrupted.\n\n    event.preventDefault();\n    debug$6('onPaste', {\n      event: event\n    });\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Change} change\n   * @param {Editor} editor\n   */\n\n\n  function onSelect(event, change, editor) {\n    if (isCopying) return true;\n    if (isComposing) return true;\n    if (editor.props.readOnly) return true; // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement;\n    debug$6('onSelect', {\n      event: event\n    });\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onChange: onChange,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragEnter: onDragEnter,\n    onDragExit: onDragExit,\n    onDragLeave: onDragLeave,\n    onDragOver: onDragOver,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n/**\n * Noop.\n *\n * @return {Void}\n */\n\n\nfunction noop() {}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$7 = Debug('slate:editor');\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor = function (_React$Component) {\n  inherits(Editor, _React$Component);\n  /**\n   * Constructor.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  function Editor(props) {\n    classCallCheck(this, Editor);\n\n    var _this = possibleConstructorReturn(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).call(this, props));\n\n    _initialiseProps$4.call(_this);\n\n    _this.state = {};\n    _this.tmp = {};\n    _this.tmp.updates = 0;\n    _this.tmp.resolves = 0; // Resolve the plugins and create a stack and schema from them.\n\n    var plugins = _this.resolvePlugins(props.plugins, props.schema);\n\n    var stack = Stack.create({\n      plugins: plugins\n    });\n    var schema = Schema.create({\n      plugins: plugins\n    });\n    _this.state.schema = schema;\n    _this.state.stack = stack; // Run `onChange` on the passed-in value because we need to ensure that it\n    // is normalized, and queue the resulting change.\n\n    var change = props.value.change();\n    stack.run('onChange', change, _this);\n\n    _this.queueChange(change);\n\n    _this.state.value = change.value; // Create a bound event handler for each event.\n\n    EVENT_HANDLERS.forEach(function (handler) {\n      _this[handler] = function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this.onEvent.apply(_this, [handler].concat(args));\n      };\n    });\n    return _this;\n  }\n  /**\n   * When the `props` are updated, create a new `Stack` if necessary and run\n   * `onChange` to ensure the value is normalized.\n   *\n   * @param {Object} props\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * When the component first mounts, flush any temporary changes,\n   * and then, focus the editor if `autoFocus` is set.\n   */\n\n  /**\n   * When the component updates, flush any temporary change.\n   */\n\n  /**\n   * Queue a `change` object, to be able to flush it later. This is required for\n   * when a change needs to be applied to the value, but because of the React\n   * lifecycle we can't apply that change immediately. So we cache it here and\n   * later can call `this.flushChange()` to flush it.\n   *\n   * @param {Change} change\n   */\n\n  /**\n   * Flush a temporarily stored `change` object, for when a change needed to be\n   * made but couldn't because of React's lifecycle.\n   */\n\n  /**\n   * Perform a change on the editor, passing `...args` to `change.call`.\n   *\n   * @param {Mixed} ...args\n   */\n\n  /**\n   * Programmatically blur the editor.\n   */\n\n  /**\n   * Programmatically focus the editor.\n   */\n\n\n  createClass(Editor, [{\n    key: 'render',\n\n    /**\n     * Render the editor.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      debug$7('render', this);\n      var children = this.stack.map('renderPortal', this.value, this).map(function (child, i) {\n        return React.createElement(Portal, {\n          key: i,\n          isOpened: true\n        }, child);\n      });\n\n      var props = _extends({}, this.props, {\n        children: children\n      });\n\n      var tree = this.stack.render('renderEditor', props, this);\n      return tree;\n    }\n    /**\n     * Resolve an array of plugins from `plugins` and `schema` props.\n     *\n     * In addition to the plugins provided in props, this will initialize three\n     * other plugins:\n     *\n     * - The top-level editor plugin, which allows for top-level handlers, etc.\n     * - The two \"core\" plugins, one before all the other and one after.\n     *\n     * @param {Array|Void} plugins\n     * @param {Schema|Object|Void} schema\n     * @return {Array}\n     */\n\n  }, {\n    key: 'schema',\n\n    /**\n     * Getters for exposing public properties of the editor's state.\n     */\n    get: function get$$1() {\n      return this.state.schema;\n    }\n  }, {\n    key: 'stack',\n    get: function get$$1() {\n      return this.state.stack;\n    }\n  }, {\n    key: 'value',\n    get: function get$$1() {\n      return this.state.value;\n    }\n    /**\n     * On event.\n     *\n     * @param {String} handler\n     * @param {Event} event\n     */\n\n    /**\n     * On change.\n     *\n     * @param {Change} change\n     */\n\n  }]);\n  return Editor;\n}(React.Component);\n/**\n * Mix in the property types for the event handlers.\n */\n\n\nEditor.propTypes = {\n  autoCorrect: Types.bool,\n  autoFocus: Types.bool,\n  className: Types.string,\n  onChange: Types.func,\n  placeholder: Types.any,\n  plugins: Types.array,\n  readOnly: Types.bool,\n  role: Types.string,\n  schema: Types.object,\n  spellCheck: Types.bool,\n  style: Types.object,\n  tabIndex: Types.number,\n  value: SlateTypes.value.isRequired\n};\nEditor.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: noop,\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true\n};\n\nvar _initialiseProps$4 = function _initialiseProps() {\n  var _this2 = this;\n\n  this.componentWillReceiveProps = function (props) {\n    var schema = _this2.schema,\n        stack = _this2.stack; // Increment the updates counter as a baseline.\n\n    _this2.tmp.updates++; // If the plugins or the schema have changed, we need to re-resolve the\n    // plugins, since it will result in a new stack and new validations.\n\n    if (props.plugins != _this2.props.plugins || props.schema != _this2.props.schema) {\n      var plugins = _this2.resolvePlugins(props.plugins, props.schema);\n\n      stack = Stack.create({\n        plugins: plugins\n      });\n      schema = Schema.create({\n        plugins: plugins\n      });\n\n      _this2.setState({\n        schema: schema,\n        stack: stack\n      }); // Increment the resolves counter.\n\n\n      _this2.tmp.resolves++; // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n\n      if (_this2.tmp.resolves > 5 && _this2.tmp.resolves == _this2.tmp.updates) {\n        logger.warn('A Slate <Editor> is re-resolving `props.plugins` or `props.schema` on each update, which leads to poor performance. This is often due to passing in a new `schema` or `plugins` prop with each render by declaring them inline in your render function. Do not do this!');\n      }\n    } // Run `onChange` on the passed-in value because we need to ensure that it\n    // is normalized, and queue the resulting change.\n\n\n    var change = props.value.change();\n    stack.run('onChange', change, _this2);\n\n    _this2.queueChange(change);\n\n    _this2.setState({\n      value: change.value\n    });\n  };\n\n  this.componentDidMount = function () {\n    _this2.flushChange();\n\n    if (_this2.props.autoFocus) {\n      _this2.focus();\n    }\n  };\n\n  this.componentDidUpdate = function () {\n    _this2.flushChange();\n  };\n\n  this.queueChange = function (change) {\n    if (change.operations.size) {\n      debug$7('queueChange', {\n        change: change\n      });\n      _this2.tmp.change = change;\n    }\n  };\n\n  this.flushChange = function () {\n    var change = _this2.tmp.change;\n\n    if (change) {\n      debug$7('flushChange', {\n        change: change\n      });\n      delete _this2.tmp.change;\n\n      _this2.props.onChange(change);\n    }\n  };\n\n  this.change = function () {\n    var _value$change;\n\n    var change = (_value$change = _this2.value.change()).call.apply(_value$change, arguments);\n\n    _this2.onChange(change);\n  };\n\n  this.blur = function () {\n    _this2.change(function (c) {\n      return c.blur();\n    });\n  };\n\n  this.focus = function () {\n    _this2.change(function (c) {\n      return c.focus();\n    });\n  };\n\n  this.onEvent = function (handler, event) {\n    _this2.change(function (change) {\n      _this2.stack.run(handler, event, change, _this2);\n    });\n  };\n\n  this.onChange = function (change) {\n    debug$7('onChange', {\n      change: change\n    });\n\n    _this2.stack.run('onChange', change, _this2);\n\n    var value = change.value;\n    var onChange = _this2.props.onChange;\n    if (value == _this2.value) return;\n    onChange(change);\n  };\n\n  this.resolvePlugins = function (plugins, schema) {\n    var beforePlugin = BeforePlugin();\n    var afterPlugin = AfterPlugin();\n    var editorPlugin = {\n      schema: schema || {}\n    };\n\n    var _loop = function _loop(_prop) {\n      // Skip `onChange` because the editor's `onChange` is special.\n      if (_prop == 'onChange') return 'continue'; // Skip `schema` because it can't be proxied easily, so it must be\n      // passed in as an argument to this function instead.\n\n      if (_prop == 'schema') return 'continue'; // Define a function that will just proxies into `props`.\n\n      editorPlugin[_prop] = function () {\n        var _props;\n\n        return _this2.props[_prop] && (_props = _this2.props)[_prop].apply(_props, arguments);\n      };\n    };\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = PLUGIN_PROPS[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _prop = _step2.value;\n\n        var _ret = _loop(_prop);\n\n        if (_ret === 'continue') continue;\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return [beforePlugin, editorPlugin].concat(toConsumableArray(plugins || []), [afterPlugin]);\n  };\n};\n\nvar _iteratorNormalCompletion = true;\nvar _didIteratorError = false;\nvar _iteratorError = undefined;\n\ntry {\n  for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n    var prop = _step.value;\n    Editor.propTypes[prop] = Types.func;\n  }\n  /**\n   * Export.\n   *\n   * @type {Component}\n   */\n\n} catch (err) {\n  _didIteratorError = true;\n  _iteratorError = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion && _iterator.return) {\n      _iterator.return();\n    }\n  } finally {\n    if (_didIteratorError) {\n      throw _iteratorError;\n    }\n  }\n}\n\nvar index = {\n  Editor: Editor,\n  cloneFragment: cloneFragment,\n  findDOMNode: findDOMNode$1,\n  findDOMRange: findDOMRange,\n  findNode: findNode,\n  findRange: findRange,\n  getEventRange: getEventRange,\n  getEventTransfer: getEventTransfer,\n  setEventTransfer: setEventTransfer,\n  AfterPlugin: AfterPlugin,\n  BeforePlugin: BeforePlugin\n};\nexport default index;\nexport { Editor, cloneFragment, findDOMNode$1 as findDOMNode, findDOMRange, findNode, findRange, getEventRange, getEventTransfer, setEventTransfer, AfterPlugin, BeforePlugin };","map":null,"metadata":{},"sourceType":"module"}